Источник: https://jenkov.com/tutorials/dependency-injection/when-to-use-dependency-injection.html

****** Когда использовать внедрение зависимостей ******

Внедрение зависимостей — это мощная техника, которую можно применять во многих ситуациях на всех
уровнях приложения. Но это не означает, что внедрение зависимостей следует использовать каждый раз,
когда класс зависит от другого класса.

Внедрение зависимостей очень эффективно при сборке слабосвязанных компонентов и при настройке этих
компонентов. Особенно, если связь между компонентами сохраняется на протяжении всего срока службы
компонентов.

В частности, внедрение зависимостей эффективно в следующих ситуациях:
- Вам необходимо внедрить данные конфигурации в один или несколько компонентов;
- Вам нужно внедрить одну и ту же зависимость в несколько компонентов;
- Вам нужно внедрить разные реализации одной и той же зависимости;
- Вам нужно внедрить одну и ту же реализацию в разные конфигурации;
- Вам нужны некоторые услуги, предоставляемые контейнером;

У этих ситуаций есть одна общая черта. Они часто сигнализируют о том, что компоненты, соединенные
вместе, представляют разные или независимые концепции, или обязанности, или принадлежат к разным
уровням абстракции в системе.

Например, конфигурация базы данных (драйвер, URL-адрес, пользователь, пароль) и реализация DataSource
- это разные понятия. Точно так же DataSource и класс DAO представляют разные концепции и относятся к
разным уровням абстракции.

Каждая из этих ситуаций более подробно описана ниже.

*** Внедрение данных конфигурации ***

Если компоненту требуются внешние данные конфигурации, внедрение зависимостей является эффективным
способом предоставления этих данных компоненту. Например, для реализации DataSource обычно требуется
как минимум четыре параметра: имя класса драйвера, URL-адрес базы данных, имя пользователя и пароль.

Вот пример, в котором используется скрипт конфигурации Butterfly Container:

*********************************************************************************************************
dbDriver   = "org.h2.Driver";
dbUrl      = "jdbc:h2:tcp://localhost/~/test";
dbUser     = "sa";
dbPassword = "";

dataSource = 1 com.jenkov.mrpersister.jdbc.SimpleDataSource(dbDriver,
                                                            dbUrl,
                                                            dbUser,
                                                            dbPassword);
*********************************************************************************************************

*** Внедрение одной и той же зависимости в несколько компонентов ***

Если вам нужно внедрить одну и ту же зависимость в несколько компонентов, зачастую проще сделать это с
помощью контейнера, чем делать это вручную. Например, одна и та же реализация DataSource часто требуется
нескольким классам DAO. Часто вы даже внедряете один и тот же экземпляр реализации DataSource во все
классы DAO.

Вот пример, в котором используется скрипт конфигурации Butterfly Container:

*********************************************************************************************************
userDao = 1 com.myapp.dao.UserDao(dataSource);
productDao = 1 com.myapp.dao.ProductDao (dataSource);
*********************************************************************************************************

Определение фабрики dataSource повторно используется из примера внедрения конфигурации (см. выше).
Фабрика dataSource была определена как синглтон, поэтому один и тот же экземпляр SimpleDataSource
внедряется как в userDao, так и в productDao.

*** Внедрение разных реализаций одной и той же зависимости ***

Иногда вам нужно внедрить разные реализации некоторой зависимости в один или несколько компонентов.
Например, если у вас есть компонент кнопки в настольном приложении с графическим интерфейсом, вы
можете внедрить различные реализации 'слушателей' мыши. В SWT у вас есть стандартный интерфейс
SelectionListener, от которого зависит каждая кнопка в вашем приложении. Когда кнопка нажата, ее
SelectionListener будет уведомлен.

Скорее всего, вам понадобится другая реализация интерфейса SelectionListener для каждой кнопки. Вот
пример, в котором используется скрипт конфигурации Butterfly Container:

*********************************************************************************************************
  button         = * org.eclipse.swt.widgets.Button($0, $1)
                      .addSelectionListener($2);
  addButton      = 1 button(parentComposite, mode,
                        com.myapp.gui.AddListener());
  validateButton = 1 button(otherComposite, mode,
                        com.myapp.gui.ValidateListener());
*********************************************************************************************************

Первое - определяется фабрика многоразовых кнопок. Это сделано для того, чтобы не писать
"org.eclipse.swt.widgets.Button" и "addSelectionListener" для каждой кнопки в сценарии.
Эта фабрика будет вводить параметры 0 и 1 в конструктор Button, а параметр 2 — в метод
addSelectionListener().

Второе - определены две разные фабрики кнопок, addButton и validateButton. Эти фабрики
вызывают фабрику кнопок с параметрами parentComposite, mode и реализацией SelectionListener.

Не беспокойтесь о параметрах parentComposite, otherComposite и mode. Это конкретные детали SWT.
Не обязательно понимать, что они из себя представляют, чтобы понять этот пример. Что важно в
этом примере, так это то, что две разные реализации интерфейса SelectionListener внедряются в
два экземпляра одного и того же компонента, класса SWT Button.

*** Внедрение одной и той же реализации в разные конфигурации ***

Внедрение зависимостей также является эффективным способом предоставления разных экземпляров
одного и того же компонента, но в разных конфигурациях, другим компонентам. Это может звучать
немного абстрактно, поэтому вот простой пример использования скрипта конфигурации Butterfly
Container:

*********************************************************************************************************
  url     = * java.net.URL($0);
  server1 = * url("http://server1.mydomain.com");
  server2 = * url("http://server2.mydomain.com");

  client  = com.jenkov.ServiceClient($0);
  client1 = client(server1);
  client2 = client(server2);
  client3 = client(url("http://server3.mydomain.com"));
*********************************************************************************************************

В этом примере определяются три клиентские фабрики. Каждый клиент зависит от экземпляра URL.
Два экземпляра URL, server1 и server2, определены ранее и внедрены в client1 и client2.
В последнюю клиентскую фабрику, client3, также вводится экземпляр URL, но экземпляр URL определяется
локально, как вызов фабрики URL. Между инъекциями в client1, client2 и client3 нет существенной
разницы. Тут показаны различные варианты конфигурации контейнера.

В приведенном выше примере важно отметить, что все три клиента зависят от одного и того же компонента,
класса java.net.URL, но каждый клиент имеет внедренный экземпляр с различной конфигурацией.

*** Использование контейнерных служб ***

Иногда вам может понадобиться не слишком много внедрения зависимостей, а скорее некоторые услуги,
предлагаемые контейнером внедрения зависимостей. Часто используемая услуга — управление жизненным
циклом. Использование контейнера внедрения зависимостей в этих ситуациях вполне допустимо. Он
объединяет управление жизненным циклом экземпляра и позволяет вам сосредоточиться на других задачах.

Вот небольшой пример синглтона, фазы жизненного цикла которого управляются контейнером Butterfly:

*********************************************************************************************************
 dataSource = 1 com.thirdparty.PoolingDataSource();
      dispose{
        $dataSource.close();
      }
*********************************************************************************************************

Синглтон dataSource определяется как экземпляр PoolingDataSource(). Затем в разделе dispose{...}
определяется фаза жизненного цикла "dispose". Фаза утилизации определяется для вызова метода close()
для синглтона. Фаза утилизации выполняется, когда контейнер Butterfly закрывается. Таким образом,
синглтон dataSource закрывается правильно и освобождает все соединения с базой данных в пуле, которые
он содержит, если контейнер закрывается.

Обратите внимание, что в экземпляр dataSource не внедрены какие-либо зависимости. Тем не менее, может
иметь смысл позволить контейнеру управлять им. Пример, конечно, несколько искусственный. Большинству
компонентов или служб потребуются какие-либо зависимости или конфигурация, чтобы иметь возможность
делать что-либо значимое. Но эти конфигурации могут быть предоставлены службе способом, отличным от
внедрения зависимостей. Например, класс PoolingDataSource может быть сторонним компонентом, и
разработчики могли позволить ему считывать свою конфигурацию из системных свойств, используя вызовы
System.getProperty(..). Как вы знаете, системные свойства задаются Java-приложениям в командной строке.

*** Когда не следует использовать внедрение зависимостей ***

Внедрение зависимостей неэффективно, если:
- Вам никогда не понадобится другая реализация.
- Вам никогда не понадобится другая конфигурация.

Если вы знаете, что никогда не измените реализацию или конфигурацию какой-либо зависимости, нет никакой
пользы от внедрения зависимостей. Это справедливо как для переменных-членов, так и для локальных
переменных. Например, если вы создаете строку с помощью StringBuilder, вы, скорее всего, никогда не
перейдете на другую реализацию StringBuilder или экземпляр с другой конфигурацией. Тогда нет причин
вводить экземпляр StringBuffer. Просто создайте экземпляр непосредственно внутри компонента.

Вот пример:

*********************************************************************************************************
public class MyComponent {

    public String toString(){
      StringBuilder builder = new StringBuilder();

      builder.append("...");

      return builder.toString();
    }
  }
*********************************************************************************************************

В этом примере нет абсолютно никаких причин делать StringBuilder, используемый в методе toString(),
членом экземпляра и внедрять его. Вам никогда не понадобится ни другая реализация, ни другой
сконфигурированный StringBuilder.

Вы должны иметь в виду, что даже если вашему приложению может никогда не понадобиться другая реализация
какого-либо компонента, все же может быть полезно иметь возможность внедрять различные фиктивные
реализации во время модульного тестирования.

*** Получение экземпляров локальных переменных из контейнера ***

Два условия в начале предыдущего раздела верны для многих локальных переменных, но было бы неправильно
сказать, что они верны для всех локальных переменных. Если методу требуется локальный экземпляр сложного
для сборки компонента, вы все равно можете получить выгоду, позволив контейнеру собрать его.

Вот простой пример класса, которому требуется экземпляр локального компонента при каждом вызове его
метода service():

*********************************************************************************************************
  public interface Factory {
    public MyLocalComponent instance(Object ... parameters);
  }

  public class MySmartComponent {
    protected Factory factory = null;

    public MySmartComponent(Factory factory){
      this.factory = factory;
    }

    public void service(){
      MyLocalComponent component = this.factory.instance();
      //... do something with local component;
    }
  }
*********************************************************************************************************

MySmartComponent имеет элемент Factory. Интерфейс Factory определяется тем же разработчиком, который
определил MySmartComponent. Это не интерфейс компонента Butterfly. Однако Butterfly Container может
внедрить фабрику контейнеров в MySmartComponent и в то же время адаптировать ее к пользовательскому
интерфейсу Factory.

Вот как это выглядит в скрипте конфигурации Butterfly Container:

*********************************************************************************************************
myLocalComponent = * com.myapp.MyLocalComponent();
mySmartComponent = * com.myapp.MySmartComponent(#myLocalComponent);
*********************************************************************************************************

Определены две фабрики, myLocalComponent и mySmartComponent. Фабрика mySmartComponent определена так,
что фабрика myLocalComponent внедряется в ее конструктор. Символ # сигнализирует о том, что вводить
следует именно саму фабрику, а не фабричный продукт. Теперь класс MySmartComponent может по желанию
получать экземпляры компонентов из фабрики myLocalFactory.