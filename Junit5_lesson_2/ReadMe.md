### Запуск тестов через Launcher

Одна из важных целей JUnit 5 — сделать интерфейс между JUnit и его программными клиентами — инструментами сборки и IDE — более мощным и стабильным. Цель состоит в том, чтобы отделить внутреннюю часть обнаружения и выполнения тестов от всей фильтрации и настройки, которые необходимы извне.

В JUnit 5 представлена концепция Launcher, которую можно использовать для обнаружения, фильтрации и выполнения тестов. Кроме того, сторонние тестовые библиотеки, такие как Spock, Cucumber и FitNesse, могут подключаться к инфраструктуре запуска платформы JUnit, предоставляя собственный TestEngine.

API launcher находится в модуле junit-platform-launcher.

Примером потребителя API launcher является ConsoleLauncher в проекте junit-platform-console.

#### Обнаружение тестов

Обнаружение тестов в качестве специальной функции самой платформы освобождает IDE и инструменты сборки от большинства трудностей, с которыми им приходилось сталкиваться при идентификации тестовых классов и тестовых методов в предыдущих версиях JUnit.

    Пример:

    LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
    .selectors(
      selectPackage("com.example.mytests"),
      selectClass(MyTestClass.class)
    )
    .filters(
      includeClassNamePatterns(".*Tests")
    )
    .build();

    try (LauncherSession session = LauncherFactory.openSession()) {
    TestPlan testPlan = session.getLauncher().discover(request);

    /* ... найти еще планы тестирования или запустить тесты */
    }

Можно выбрать классы, методы и все классы в пакете или даже выполнить поиск всех тестов в пути к классам или пути к модулю. Обнаружение происходит во всех участвующих тестовых движках.

Результирующий TestPlan представляет собой иерархическое (и доступное только для чтения) описание всех механизмов, классов и методов тестирования, которые соответствуют LauncherDiscoveryRequest. Клиент может пройти по дереву, получить сведения об узле и получить ссылку на исходный источник (например, класс, метод или позицию в файле). Каждый узел в плане тестирования имеет уникальный идентификатор, который можно использовать для запуска определенного теста или группы тестов.

Клиенты могут зарегистрировать одну или несколько реализаций LauncherDiscoveryListener через LauncherDiscoveryRequestBuilder, чтобы получить представление о событиях, происходящих во время обнаружения тестов. По умолчанию построитель регистрирует listener «прекращение при сбое», который прерывает нахождение теста после того, как обнаружена первая ошибка обнаружения. LauncherDiscoveryListener по умолчанию можно изменить с помощью параметра конфигурации junit.platform.discovery.listener.default.

#### Запуск тестов

Для выполнения тестов клиенты могут использовать тот же LauncherDiscoveryRequest, что и на этапе обнаружения, или создать новый запрос. Ход выполнения теста и создание отчетов можно получить, зарегистрировав одну или несколько реализаций TestExecutionListener в средстве запуска, как показано в примере:

    LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder.request()
    .selectors(
    selectPackage("com.example.mytests"),
    selectClass(MyTestClass.class)
    )
    .filters(
    includeClassNamePatterns(".*Tests")
    )
    .build();
    
    SummaryGeneratingListener listener = new SummaryGeneratingListener();
    
    try (LauncherSession session = LauncherFactory.openSession()) {
    Launcher launcher = session.getLauncher();
    /* Регисттируем слушателя по выбору */
    launcher.registerTestExecutionListeners(listener);
    /* Найти тесты и составить план тестирования */
    TestPlan testPlan = launcher.discover(request);
    /* Выполнить план тестов */
    launcher.execute(testPlan);
    /* В качестве альтернативы, выполните запрос напрямую */
    launcher.execute(request);
    }
    
    TestExecutionSummary summary = listener.getSummary();
    /* Сделать что-нибудь с результатами ... */

Для метода *.execute() нет возвращаемого значения, но можно использовать TestExecutionListener для агрегирования результатов. Примеры см. в разделах SummaryGeneratingListener, LegacyXmlReportGeneratingListener и UniqueIdTrackingListener официальной документации к Junit 5 (https://junit.org/junit5/docs/current/user-guide/)

В нашем случае класс AllTestRunnerLauncher исследует принципы работы с концепцией Launcher фреймворка Junit 5. 

### Test Driven Development concept

В данной ситуации мы пишем условно "игровой код", т.е. например реальное размещение данных пользователя в базе данных, мы заменяем на добавление его в обычный список и т.п. (мы изучаем Junit5 и связанные с ним технологии и концепции)

И так TDD - разработка через тестирование, предполагается, что сначала мы пишем некие тестовые методы, которые, должны при определенных данных на входе давать совершенно конкретные данные (результаты) на выходе.

В нашем тестовом классе TddMethodLess.java добавляем тестовые методы на которые еще не написан функционал:

- Первый тестовый метод loginSuccessIfUserExists() должен проверить существует ли конкретный пользователь в базе (списке) данных. Для реализации мы естественно добавляем искомого пользователя в базу (список), а затем запускаем метод, который пока имеет название *.login(name, pass). <br><br> 
  Данного метода в используемом классе заведомо нет. Естественно мы предполагаем, что все таки, данный метод нам что-то вернул. И по скольку мы добавили вполне конкретный объект в список пользователей, то данный метод *.login(name, pass) должен вернуть именно этого пользователя. Естественно, если метод написан неправильно или по каким-то причинам пользователь не был добавлен в список то мы получим пустой объект Optional и его проверка методом *.isPresent() даст false, в противном случае true и теоретически тестовый метод *.assertTrue() должен зафиксировать провал в первом случае и прохождение теста во втором. <br><br>
  Но метода *.login(name, pass) в тестируемом классе UserService нет и естественно тест упадет. Вот теперь переходим в тестируемый код и:<br><br>
  - ШАГ 1. Создаем метод *.login(name, pass) в классе UserService. <br><br>
  - ШАГ 2. Дополняем класс User необходимыми полями: id, username, password. При реализации класса используем Lombok (см. pom.xml) <br><br>
  - ШАГ 3. Повторно запускаем тест *.loginSuccessIfUserExists() <br><br>
  
  Это демонстрация метода *.assertTrue() фреймворка Junit 5<br><br>

- Второй наш тест equalsUserFromLoginForm() проверяет, соответствует ли введенный пароль и логин данным в БД (списке пользователей) конкретному пользователю. <br><br>
  Логика разработки такая же как и в первом случае, мы сначала написали тестовый метод в котором мы добавляем в базу конкретного пользователя, далее извлекаем этого пользователя из базы методом *.login(name, pass), который был написан для первого теста. Метод должен вернуть Optional объект, и желательно именно того, которого мы добавили. <br><br>
  На данном этапе мы проверяем логику работы метода *.login(name, pass) и большая часть работы была сделана на первом этапе - написании самого тестируемого метода *.login(name, pass). <br><br>
  Но самое главное, мы смотрим на работу метода *.assertEquals() фреймворка Junit 5 <br><br>
- Тесты *.loginFailIfPasswordNotCorrect() и *.loginFailIfUserNotExist() проверяют тот же метод *.login(name, pass) при различных ошибках ввода или ввода заведомо несуществующих данных в БД (в списке пользователей).

Схему разработки по TDD см. рис. DOC/TDD.jpg